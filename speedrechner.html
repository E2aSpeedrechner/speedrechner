<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Speedrechner – Polizei GAL E2a</title>

<style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin-top: 60px;
    }

    /* Fixed UI (immer sichtbar) */
    #hint {
        position: fixed;
        left: 10px;
        top: 10px;
        font-size: 13px;
        color: #555;
    }

    .btn {
        position: fixed;
        left: 10px;
        font-size: 13px;
        padding: 9px 18px;          /* ~50% größer als vorher */
        cursor: pointer;
    }

    #restart {
        top: 34px;
    }

    /* PDF Button (nur in Auswertung sichtbar) */
    #pdfBtn {
        position: fixed;
        right: 10px;
        top: 10px;
        font-size: 13px;
        padding: 9px 18px;          /* gleiche Größe wie Neu starten */
        cursor: pointer;
        display: none;
    }

    /* Übungs-Header */
    #titlePractice {
        font-weight: bold;
        color: #7a0000;             /* dunkelrot */
        font-size: 56px;            /* ca. 2× so groß wie "Auswertung" (28px) */
        margin: 0 0 25px 0;         /* Abstand zu Zahlen */
    }

    .zahl {
        font-size: 60px;
        margin: 10px;
    }

    #eingabe {
        font-size: 26px;
        width: 70px;
        text-align: center;
        margin-top: 30px;
    }

    #info {
        margin-top: 30px;
        font-size: 16px;
    }

    .green { color: green; }
    .red { color: red; }

    #statistik {
        width: 900px;
        margin: 0 auto;
        display: none;
    }

    canvas {
        margin-top: 10px;
        border: 1px solid #ccc;
    }

    h2 {
        color: #007acc;
        font-weight: bold;
        font-size: 28px;
        margin: 0 0 10px 0;
    }

    h3 {
        color: #007acc;
        font-weight: bold;
        font-size: 20px;
        margin: 0;
    }

    /* Mehr Abstand zwischen Ø Eingaben/min und "Geschwindigkeit" */
    #spacerStats {
        height: 18px; /* ca. doppelt so groß wie vorher */
    }

    /* Auswertung-Textblock */
    #summary p {
        margin: 8px 0;
    }
</style>
</head>

<body>

<div id="hint">ESC = Abbrechen</div>
<button id="restart" class="btn" onclick="location.reload()">Neu starten</button>
<button id="pdfBtn">Ergebnis als PDF herunterladen</button>

<div id="content">
    <div id="titlePractice">Speedrechner</div>

    <div id="oben" class="zahl"></div>
    <div id="plus" class="zahl">+</div>
    <div id="unten" class="zahl"></div>

    <input id="eingabe" type="number" maxlength="1" inputmode="numeric" autofocus>
    <div id="info"></div>
</div>

<div id="statistik">
    <h3>Geschwindigkeit</h3>
    <canvas id="chart" width="900" height="340"></canvas>
</div>

<!-- jsPDF (für PDF-Download im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
/* ---------------- Einstellungen ---------------- */
const TESTDAUER = 20 * 60;
/* ----------------------------------------------- */

let startzeit = Date.now();
let richtig = 0;
let falsch = 0;
let ersteRunde = true;

let aktuelleZahl = zufall();
let gemerkteZahl = zufall();
let eingabeZeiten = [];

const content = document.getElementById("content");
const oben = document.getElementById("oben");
const unten = document.getElementById("unten");
const plus = document.getElementById("plus");
const eingabe = document.getElementById("eingabe");
const info = document.getElementById("info");
const statistik = document.getElementById("statistik");
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");
const pdfBtn = document.getElementById("pdfBtn");

let letzteAuswertung = null; // wird in ende() gesetzt

oben.textContent = aktuelleZahl;
unten.textContent = gemerkteZahl;

/* Sofort prüfen */
eingabe.addEventListener("input", () => {
  if (eingabe.value.length === 1) pruefen();
});

/* ESC abbrechen */
document.addEventListener("keydown", e => {
  if (e.key === "Escape") ende(true);
});

function zufall() {
  return Math.floor(Math.random() * 9) + 1;
}

function pruefen() {
  const wert = parseInt(eingabe.value);
  if (isNaN(wert)) return;

  eingabeZeiten.push(Date.now());

  const korrekt = (aktuelleZahl + gemerkteZahl) % 10;
  wert === korrekt ? richtig++ : falsch++;

  if (ersteRunde) {
    unten.style.display = "none";
    plus.style.display = "none";
    ersteRunde = false;
  }

  gemerkteZahl = aktuelleZahl;
  aktuelleZahl = zufall();
  oben.textContent = aktuelleZahl;

  eingabe.value = "";
  updateInfo();
}

function updateInfo() {
  const vergangen = Math.floor((Date.now() - startzeit) / 1000);
  const rest = Math.max(0, TESTDAUER - vergangen);

  const min = String(Math.floor(rest / 60)).padStart(2, "0");
  const sec = String(rest % 60).padStart(2, "0");

  info.innerHTML =
    `Zeit: ${min}:${sec} | ` +
    `Richtig: <span class="green">${richtig}</span> | ` +
    `Falsch: <span class="red">${falsch}</span>`;

  if (rest === 0) ende(false);
}

function berechneBuckets() {
  let buckets = {};
  eingabeZeiten.forEach(t => {
    const h = Math.floor((t - startzeit) / 30000) / 2; // 0.5-Minuten buckets
    buckets[h] = (buckets[h] || 0) + 1;
  });
  return buckets;
}

/* leichte Glättung */
function glaetten(arr) {
  return arr.map((v, i, a) => i === 0 ? v : (v + a[i - 1]) / 2);
}

/* runder zeichnen: lineJoin/lineCap + anti-aliasing */
function zeichneKurve(buckets) {
  statistik.style.display = "block";
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const zeiten = Object.keys(buckets).map(Number).sort((a, b) => a - b);

  // Wenn extrem kurz: wenigstens zwei Punkte, damit Linie sichtbar wird
  if (zeiten.length === 1) zeiten.push(zeiten[0] + 0.5);

  const roh = zeiten.map(z => buckets[z] || 0);
  const werte = glaetten(roh);

  const maxY = Math.max(...werte, 5);
  const pad = 55;

  ctx.font = "bold 12px Arial";

  // Achsentitel
  ctx.fillText("Zeit", pad, canvas.height - 10);
  ctx.fillText("Eingaben / Minute", canvas.width - 160, pad - 20);

  // Raster X: 0.5 Min
  ctx.strokeStyle = "#eee";
  zeiten.forEach((z, i) => {
    const x = pad + i * ((canvas.width - 2 * pad) / zeiten.length);
    ctx.beginPath();
    ctx.moveTo(x, pad);
    ctx.lineTo(x, canvas.height - pad);
    ctx.stroke();
    ctx.fillText(z.toFixed(1), x - 10, canvas.height - pad + 18);
  });

  // Raster Y: 5er Schritte
  for (let y = 0; y <= maxY + 5; y += 5) {
    const py = canvas.height - pad - (y / maxY) * (canvas.height - 2 * pad);
    ctx.beginPath();
    ctx.moveTo(pad, py);
    ctx.lineTo(canvas.width - pad, py);
    ctx.stroke();
    ctx.fillText(y, canvas.width - pad + 8, py + 4);
  }

  // Kurve (blau, rund)
  ctx.beginPath();
  ctx.strokeStyle = "#007acc";
  ctx.lineWidth = 2;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  werte.forEach((v, i) => {
    const x = pad + i * ((canvas.width - 2 * pad) / (werte.length - 1 || 1));
    const y = canvas.height - pad - (v / maxY) * (canvas.height - 2 * pad);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });

  ctx.stroke();

  return { zeiten, werte, maxY };
}

function ende(abbruch) {
  // PDF-Button sichtbar machen
  pdfBtn.style.display = "block";

  const dauerMin = (Date.now() - startzeit) / 60000;
  const gesamt = richtig + falsch;
  const avgProMin = (gesamt / dauerMin) || 0;

  // Auswertungs-HTML (mit extra Abstand zwischen Ø und Geschwindigkeit)
  content.innerHTML = `
    <h2>Auswertung</h2>
    <div id="summary">
      <p>${abbruch ? "Abgebrochen" : "Beendet"}</p>
      <p>Richtig: <span class="green">${richtig}</span></p>
      <p>Falsch: <span class="red">${falsch}</span></p>
      <p>Ø Eingaben / Minute: ${avgProMin.toFixed(1)}</p>
      <div id="spacerStats"></div>
    </div>
  `;

  const buckets = berechneBuckets();
  const chartData = zeichneKurve(buckets);

  // Merken fürs PDF
  letzteAuswertung = {
    abbruch,
    richtig,
    falsch,
    avgProMin: a
